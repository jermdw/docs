{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Dojo! \u00b6 We are all Ninjas here.","title":"Home"},{"location":"#welcome-to-the-dojo","text":"We are all Ninjas here.","title":"Welcome to the Dojo!"},{"location":"cheatsheets/","text":"Cheatsheets \u00b6 Vim Linux \u00b6 Systemd - systemctl \u00b6 The systemctl command is which is the central management tool for controlling the init system. List all running services \u00b6 systemctl Start a service \u00b6 sudo systemctl start application Stop a service \u00b6 sudo systemctl stop application Enable a service \u00b6 References \u00b6 DigitalOcean: How To Use Systemctl to Manage Systemd Services and Units FreeDesktop.org - systemctl Filesystem Hierarchy Standard \u00b6 Linux filesystem root directories and their respective purposes. According to the Filesystem Hierarchy Standard 3.0 . Directory Purpose bin Essential binaries boot Static boot-related files dev Device files etc Host-specific system configuration. lib Essential shared libraries and kernel modules media Mount point for removable media mnt Mount point for temporarily mounting a filesystem opt Add-on software run Data relevant to running processes; /var/run is used more frequently sbin Essential system binaries srv Data for services provided tmp Temporary files usr Secondary hierarchy; identical to primary (root) hierarchy var Variable (non-static) data","title":"Cheatsheets"},{"location":"cheatsheets/#cheatsheets","text":"Vim","title":"Cheatsheets"},{"location":"cheatsheets/#linux","text":"","title":"Linux"},{"location":"cheatsheets/#systemd-systemctl","text":"The systemctl command is which is the central management tool for controlling the init system.","title":"Systemd - systemctl"},{"location":"cheatsheets/#list-all-running-services","text":"systemctl","title":"List all running services"},{"location":"cheatsheets/#start-a-service","text":"sudo systemctl start application","title":"Start a service"},{"location":"cheatsheets/#stop-a-service","text":"sudo systemctl stop application","title":"Stop a service"},{"location":"cheatsheets/#enable-a-service","text":"","title":"Enable a service"},{"location":"cheatsheets/#references","text":"DigitalOcean: How To Use Systemctl to Manage Systemd Services and Units FreeDesktop.org - systemctl","title":"References"},{"location":"cheatsheets/#filesystem-hierarchy-standard","text":"Linux filesystem root directories and their respective purposes. According to the Filesystem Hierarchy Standard 3.0 . Directory Purpose bin Essential binaries boot Static boot-related files dev Device files etc Host-specific system configuration. lib Essential shared libraries and kernel modules media Mount point for removable media mnt Mount point for temporarily mounting a filesystem opt Add-on software run Data relevant to running processes; /var/run is used more frequently sbin Essential system binaries srv Data for services provided tmp Temporary files usr Secondary hierarchy; identical to primary (root) hierarchy var Variable (non-static) data","title":"Filesystem Hierarchy Standard"},{"location":"lablocal/","text":"Lab.Local Information \u00b6 Information about Lab.Local homelab. Environment Overview \u00b6 Hosts \u00b6 IP Address Hostname Notes 192.168.1.15 TREASURESAVER Western Digital EX2 NAS 192.168.1.118 wizvcenter vCenter Server Appliance 192.168.1.120 wizesxi ESXi Hypervisor 192.168.1.121 wizesxi2 ESXi Hypervisor 192.168.1.1 badgergate pFsense SG-3100 firewall 192.168.1.113 gs1900 ZyXEL managed switch 192.168.1.111 netwitness Packet Capture Server 192.168.1.5 pihole Raspberry Pi DNS server 192.168.1.11 graylog Graylog Server 192.168.1.10 badger-5510 Ubuntu 18.04 Server 192.168.1.175 wizdc1 Windows Server 2016 Domain Controller 192.168.1.181 wizdc2 Windows Server 2018 Domain Controller 192.168.1.100 - 192.168.1.200 Client Device DHCP Scope","title":"Lab.Local"},{"location":"lablocal/#lablocal-information","text":"Information about Lab.Local homelab.","title":"Lab.Local Information"},{"location":"lablocal/#environment-overview","text":"","title":"Environment Overview"},{"location":"lablocal/#hosts","text":"IP Address Hostname Notes 192.168.1.15 TREASURESAVER Western Digital EX2 NAS 192.168.1.118 wizvcenter vCenter Server Appliance 192.168.1.120 wizesxi ESXi Hypervisor 192.168.1.121 wizesxi2 ESXi Hypervisor 192.168.1.1 badgergate pFsense SG-3100 firewall 192.168.1.113 gs1900 ZyXEL managed switch 192.168.1.111 netwitness Packet Capture Server 192.168.1.5 pihole Raspberry Pi DNS server 192.168.1.11 graylog Graylog Server 192.168.1.10 badger-5510 Ubuntu 18.04 Server 192.168.1.175 wizdc1 Windows Server 2016 Domain Controller 192.168.1.181 wizdc2 Windows Server 2018 Domain Controller 192.168.1.100 - 192.168.1.200 Client Device DHCP Scope","title":"Hosts"},{"location":"malware/","text":"Malware Analysis \u00b6 Toolkit \u00b6 Portable Executable Inspection \u00b6 Debugger \u00b6 Analysis Techniques \u00b6 Static Analysis \u00b6 Examination of the executable file without viewing the actual instructions. Basic static analysis can confirm whether a file is malicious, provide information about its functionality. Advantages: straightforward and quick. Disadvantages: ineffective against complex malware, unable to determine malware's behaviorial characteristics. Dynamic Analysis \u00b6 Runtime analysis of malware. Involves running the malware and observing its behavior. Advantage : can provide thorough understanding of malware behavior. Disadvantage: can be time consuming and requires additional setup to ensure safety. Basic Static Analysis \u00b6 Finding Strings \u00b6 The strings program searches an executable for strings, which are typically stored in either ASCII or Unicode format. Both ASCII and Unicode formats store characters in sequences that end with a NULL terminator to indicate that the string is complete. ASCII strings use 1 byte per character, and Unicode uses 2 bytes per character. strings2 Packed / Obfuscated Malware \u00b6 Note Packed and obfuscated code will often include at least the functions LoadLibrary and GetProcAddress , which are used to load and gain access to additional functions. UPX PEid Portable Executable File Format \u00b6 The Portable Executable (PE) file format is used by Windows executables, object code, and DLLs. The PE file format is a data structure that contains the information necessary for the Windows OS loader to manage the wrapped executable code. Nearly every file with executable code that is loaded by Windows is in the PE file format, though some legacy file formats do appear on rare occasion in malware. PE files begin with a header that includes information about the code, the type of application, required library functions, and space requirements. The information in the PE header is of great value to the malware analyst. Linked Libraries & Functions \u00b6 Static, Runtime, and Dynamic Linking \u00b6 Dynamically Linked Functions \u00b6 Dependency Walker Common DLLs \u00b6 DLL Description Kernel32.dll This is a very common DLL that contains core functionality, such as access and manipulation of memory, files, and hardware. Advapi32.dll This DLL provides access to advanced core Windows components such as the Service Manager and Registry. User32.dll This DLL contains all the user-interface components, such as buttons, scroll bars, and components for controlling and responding to user actions. Gdi32.dll This DLL contains functions for displaying and manipulating graphics. Ntdll.dll This DLL is the interface to the Windows kernel. Executables generally do not import this file directly, although it is always imported indirectly by Kernel32.dll. If an executable imports this file, it means that the author intended to use functionality not normally available to Windows programs. Some tasks, such as hiding functionality or manipulating processes, will use this interface. WSock32.dll, Ws2_32.dll These are networking DLLs. A program that accesses either of these most likely connects to a network or performs network-related tasks. Wininet.dll This DLL contains higher-level networking functions that implement protocols such as FTP, HTTP, and NTP. FUNCTION NAMING CONVENTIONS When evaluating unfamiliar Windows functions, a few naming conventions are worth noting because they come up often and might confuse you if you don\u2019t recognize them. For example, you will often encounter function names with an Ex suffix, such as CreateWindowEx. When Microsoft updates a function and the new function is incompatible with the old one, Microsoft continues to support the old function. The new function is given the same name as the old function, with an added Ex suffix. Functions that have been significantly updated twice have two Ex suffixes in their names. Many functions that take strings as parameters include an A or a W at the end of their names, such as CreateDirectoryW. This letter does not appear in the documentation for the function; it simply indicates that the function accepts a string parameter and that there are two different versions of the function: one for ASCII strings and one for wide character strings. Remember to drop the trailing A or W when searching for the function in the Microsoft documentation. Imported Functions \u00b6 The PE file header also includes information about specific functions used by an executable. The names of these Windows functions can give you a good idea about what the executable does. Microsoft does an excellent job of documenting the Windows API through the Microsoft Developer Network (MSDN) library. Exported Functions \u00b6 In many cases, software authors name their exported functions in a way that provides useful information. One common convention is to use the name used in the Microsoft documentation. For example, in order to run a program as a service, you must first define a ServiceMain function. The presence of an exported function called ServiceMain tells you that the malware runs as part of a service. Unfortunately, while the Microsoft documentation calls this function ServiceMain, and it\u2019s common for programmers to do the same, the function can have any name. Therefore, the names of exported functions are actually of limited use against sophisticated malware. If malware uses exports, it will often either omit names entirely or use unclear or misleading names. The PE File Headers and Sections \u00b6 PE file headers can provide considerably more information than just imports. The PE file format contains a header followed by a series of sections. The header contains metadata about the file itself. Following the header are the actual sections of the file, each of which contains useful information. As we progress through the book, we will continue to discuss strategies for viewing the information in each of these sections. The following are the most common and interesting sections in a PE file: .text. The .text section contains the instructions that the CPU executes. All other sections store data and supporting information. Generally, this is the only section that can execute, and it should be the only section that includes code. .rdata. The .rdata section typically contains the import and export information, which is the same information available from both Dependency Walker and PEview. This section can also store other read-only data used by the program. Sometimes a file will contain an .idata and .edata section, which store the import and export information (see Table 1-4). .data. The .data section contains the program\u2019s global data, which is accessible from anywhere in the program. Local data is not stored in this section, or anywhere else in the PE file. (We address this topic in Chapter 6.) .rsrc. The .rsrc section includes the resources used by the executable that are not considered part of the executable, such as icons, images, menus, and strings. Strings can be stored either in the .rsrc section or in the main program, but they are often stored in the .rsrc section for multilanguage support. Section names are often consistent across a compiler, but can vary across different compilers. For example, Visual Studio uses .text for executable code, but Borland Delphi uses CODE. Windows doesn\u2019t care about the actual name since it uses other information in the PE header to determine how a section is used. Furthermore, the section names are sometimes obfuscated to make analysis more difficult. Luckily, the default names are used most of the time. Table 1-4 lists the most common you\u2019ll encounter. Table 1-4. Sections of a PE File for a Windows Executable \u00b6 Executable Description .text Contains the executable code .rdata Holds read-only data that is globally accessible within the program .data Stores global data accessed throughout the program .idata Sometimes present and stores the import function information; if this section is not present, the import function information is stored in the .rdata section .edata Sometimes present and stores the export function information; if this section is not present, the export function information is stored in the .rdata section .pdata Present only in 64-bit executables and stores exception-handling information .rsrc Stores resources needed by the executable .reloc Contains information for relocation of library files Static Analysis in Practice \u00b6","title":"Malware Analysis"},{"location":"malware/#malware-analysis","text":"","title":"Malware Analysis"},{"location":"malware/#toolkit","text":"","title":"Toolkit"},{"location":"malware/#portable-executable-inspection","text":"","title":"Portable Executable Inspection"},{"location":"malware/#debugger","text":"","title":"Debugger"},{"location":"malware/#analysis-techniques","text":"","title":"Analysis Techniques"},{"location":"malware/#static-analysis","text":"Examination of the executable file without viewing the actual instructions. Basic static analysis can confirm whether a file is malicious, provide information about its functionality. Advantages: straightforward and quick. Disadvantages: ineffective against complex malware, unable to determine malware's behaviorial characteristics.","title":"Static Analysis"},{"location":"malware/#dynamic-analysis","text":"Runtime analysis of malware. Involves running the malware and observing its behavior. Advantage : can provide thorough understanding of malware behavior. Disadvantage: can be time consuming and requires additional setup to ensure safety.","title":"Dynamic Analysis"},{"location":"malware/#basic-static-analysis","text":"","title":"Basic Static Analysis"},{"location":"malware/#finding-strings","text":"The strings program searches an executable for strings, which are typically stored in either ASCII or Unicode format. Both ASCII and Unicode formats store characters in sequences that end with a NULL terminator to indicate that the string is complete. ASCII strings use 1 byte per character, and Unicode uses 2 bytes per character. strings2","title":"Finding Strings"},{"location":"malware/#packed-obfuscated-malware","text":"Note Packed and obfuscated code will often include at least the functions LoadLibrary and GetProcAddress , which are used to load and gain access to additional functions. UPX PEid","title":"Packed / Obfuscated Malware"},{"location":"malware/#portable-executable-file-format","text":"The Portable Executable (PE) file format is used by Windows executables, object code, and DLLs. The PE file format is a data structure that contains the information necessary for the Windows OS loader to manage the wrapped executable code. Nearly every file with executable code that is loaded by Windows is in the PE file format, though some legacy file formats do appear on rare occasion in malware. PE files begin with a header that includes information about the code, the type of application, required library functions, and space requirements. The information in the PE header is of great value to the malware analyst.","title":"Portable Executable File Format"},{"location":"malware/#linked-libraries-functions","text":"","title":"Linked Libraries &amp; Functions"},{"location":"malware/#static-runtime-and-dynamic-linking","text":"","title":"Static, Runtime, and Dynamic Linking"},{"location":"malware/#dynamically-linked-functions","text":"Dependency Walker","title":"Dynamically Linked Functions"},{"location":"malware/#common-dlls","text":"DLL Description Kernel32.dll This is a very common DLL that contains core functionality, such as access and manipulation of memory, files, and hardware. Advapi32.dll This DLL provides access to advanced core Windows components such as the Service Manager and Registry. User32.dll This DLL contains all the user-interface components, such as buttons, scroll bars, and components for controlling and responding to user actions. Gdi32.dll This DLL contains functions for displaying and manipulating graphics. Ntdll.dll This DLL is the interface to the Windows kernel. Executables generally do not import this file directly, although it is always imported indirectly by Kernel32.dll. If an executable imports this file, it means that the author intended to use functionality not normally available to Windows programs. Some tasks, such as hiding functionality or manipulating processes, will use this interface. WSock32.dll, Ws2_32.dll These are networking DLLs. A program that accesses either of these most likely connects to a network or performs network-related tasks. Wininet.dll This DLL contains higher-level networking functions that implement protocols such as FTP, HTTP, and NTP. FUNCTION NAMING CONVENTIONS When evaluating unfamiliar Windows functions, a few naming conventions are worth noting because they come up often and might confuse you if you don\u2019t recognize them. For example, you will often encounter function names with an Ex suffix, such as CreateWindowEx. When Microsoft updates a function and the new function is incompatible with the old one, Microsoft continues to support the old function. The new function is given the same name as the old function, with an added Ex suffix. Functions that have been significantly updated twice have two Ex suffixes in their names. Many functions that take strings as parameters include an A or a W at the end of their names, such as CreateDirectoryW. This letter does not appear in the documentation for the function; it simply indicates that the function accepts a string parameter and that there are two different versions of the function: one for ASCII strings and one for wide character strings. Remember to drop the trailing A or W when searching for the function in the Microsoft documentation.","title":"Common DLLs"},{"location":"malware/#imported-functions","text":"The PE file header also includes information about specific functions used by an executable. The names of these Windows functions can give you a good idea about what the executable does. Microsoft does an excellent job of documenting the Windows API through the Microsoft Developer Network (MSDN) library.","title":"Imported Functions"},{"location":"malware/#exported-functions","text":"In many cases, software authors name their exported functions in a way that provides useful information. One common convention is to use the name used in the Microsoft documentation. For example, in order to run a program as a service, you must first define a ServiceMain function. The presence of an exported function called ServiceMain tells you that the malware runs as part of a service. Unfortunately, while the Microsoft documentation calls this function ServiceMain, and it\u2019s common for programmers to do the same, the function can have any name. Therefore, the names of exported functions are actually of limited use against sophisticated malware. If malware uses exports, it will often either omit names entirely or use unclear or misleading names.","title":"Exported Functions"},{"location":"malware/#the-pe-file-headers-and-sections","text":"PE file headers can provide considerably more information than just imports. The PE file format contains a header followed by a series of sections. The header contains metadata about the file itself. Following the header are the actual sections of the file, each of which contains useful information. As we progress through the book, we will continue to discuss strategies for viewing the information in each of these sections. The following are the most common and interesting sections in a PE file: .text. The .text section contains the instructions that the CPU executes. All other sections store data and supporting information. Generally, this is the only section that can execute, and it should be the only section that includes code. .rdata. The .rdata section typically contains the import and export information, which is the same information available from both Dependency Walker and PEview. This section can also store other read-only data used by the program. Sometimes a file will contain an .idata and .edata section, which store the import and export information (see Table 1-4). .data. The .data section contains the program\u2019s global data, which is accessible from anywhere in the program. Local data is not stored in this section, or anywhere else in the PE file. (We address this topic in Chapter 6.) .rsrc. The .rsrc section includes the resources used by the executable that are not considered part of the executable, such as icons, images, menus, and strings. Strings can be stored either in the .rsrc section or in the main program, but they are often stored in the .rsrc section for multilanguage support. Section names are often consistent across a compiler, but can vary across different compilers. For example, Visual Studio uses .text for executable code, but Borland Delphi uses CODE. Windows doesn\u2019t care about the actual name since it uses other information in the PE header to determine how a section is used. Furthermore, the section names are sometimes obfuscated to make analysis more difficult. Luckily, the default names are used most of the time. Table 1-4 lists the most common you\u2019ll encounter.","title":"The PE File Headers and Sections"},{"location":"malware/#table-1-4-sections-of-a-pe-file-for-a-windows-executable","text":"Executable Description .text Contains the executable code .rdata Holds read-only data that is globally accessible within the program .data Stores global data accessed throughout the program .idata Sometimes present and stores the import function information; if this section is not present, the import function information is stored in the .rdata section .edata Sometimes present and stores the export function information; if this section is not present, the export function information is stored in the .rdata section .pdata Present only in 64-bit executables and stores exception-handling information .rsrc Stores resources needed by the executable .reloc Contains information for relocation of library files","title":"Table 1-4. Sections of a PE File for a Windows Executable"},{"location":"malware/#static-analysis-in-practice","text":"","title":"Static Analysis in Practice"},{"location":"scripts/","text":"Scripts \u00b6 Windows \u00b6 Join Computer to Active Directory Domain. Linux \u00b6","title":"Scripts"},{"location":"scripts/#scripts","text":"","title":"Scripts"},{"location":"scripts/#windows","text":"Join Computer to Active Directory Domain.","title":"Windows"},{"location":"scripts/#linux","text":"","title":"Linux"}]}